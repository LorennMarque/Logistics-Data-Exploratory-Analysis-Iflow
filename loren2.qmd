---
title: "Untitled"
format: html
editor: visual
---

```{r}

# Librerías
library(dplyr)
library(ggplot2)
library(leaflet)
# Cargar librerías necesarias
library(geosphere)
library(igraph)

# Cargar datos
data <- read.csv("iflow_clean.csv")
```

## Primeras entregas de cada día

Cada punto azul es la primera entrega de un día. Si hacemos un cluster podemos estimar ubicaciones de partida o intentar averiguar porque están tan dispersas

```{r echo=FALSE}
# Asegurar que las columnas de fecha y hora estén en formato POSIXct
data <- data %>%
  mutate(
    fin_visita = as.POSIXct(fin_visita, format = "%Y-%m-%d %H:%M:%S")
  )

# Encontrar la primera entrega de cada día
primeras_entregas <- data %>%
  mutate(fecha = as.Date(fin_visita)) %>%
  group_by(fecha) %>%
  filter(fin_visita == min(fin_visita)) %>%
  ungroup()

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = primeras_entregas) %>%
  addTiles() %>%
  addCircleMarkers(
    ~longitud, ~latitud,
    radius = 3,
    color = "blue",
    fillOpacity = 0.8,
    popup = ~paste("Fecha:", fecha, "<br>Cliente:", cliente, "<br>Hora:", fin_visita)
  ) %>%
  addLegend(
    "bottomright", 
    colors = "blue", 
    labels = "Primera Entrega", 
    title = "Leyenda"
  )

# Mostrar el mapa
mapa_leaflet
```

## Primera y segunda entrega de cada día.

Los puntos rojos son la segunda entrega del día.

Cada punto azul debería estar muy cerca de un punto rojo y no debería existir ningún otra entrega entre esos dos puntos.

Si demostramos que en algún dia existen entrega entre los primeros k puntos del dia podríamos decir que las entregas no son eficientes

```{r echo=FALSE}
# Encontrar la primera y la segunda entrega de cada día
entregas_dia <- data %>%
  mutate(fecha = as.Date(fin_visita)) %>%
  group_by(fecha) %>%
  arrange(fin_visita) %>%  # Ordenar por hora de finalización
  slice(1:2) %>%  # Seleccionar las dos primeras entregas
  mutate(tipo = ifelse(row_number() == 1, "Primera Entrega", "Segunda Entrega")) %>%
  ungroup()

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = entregas_dia) %>%
  addTiles() %>%
  addCircleMarkers(
    data = entregas_dia %>% filter(tipo == "Primera Entrega"),
    ~longitud, ~latitud,
    radius = 5,
    color = "blue",
    fillOpacity = 0.8,
    popup = ~paste("Fecha:", fecha, "<br>Cliente:", cliente, "<br>Hora:", fin_visita)
  ) %>%
  addCircleMarkers(
    data = entregas_dia %>% filter(tipo == "Segunda Entrega"),
    ~longitud, ~latitud,
    radius = 5,
    color = "red",
    fillOpacity = 0.8,
    popup = ~paste("Fecha:", fecha, "<br>Cliente:", cliente, "<br>Hora:", fin_visita)
  ) %>%
  addLegend(
    "bottomright", 
    colors = c("blue", "red"), 
    labels = c("Primera Entrega", "Segunda Entrega"), 
    title = "Leyenda"
  )

# Mostrar el mapa
mapa_leaflet
```

## Entregas ordenadas cronológicamente.

Podemos ver las entregas de un solo día para entender la trayectoria.

```{r}
# Parámetros: Selección de fecha específica y cantidad de entregas 
fecha_seleccionada <- as.Date("2024-05-23")  
n_entregas <- 20
```

```{r echo=FALSE}
# Filtrar las entregas para la fecha seleccionada y ordenarlas por hora
entregas_fecha <- data %>%
  filter(as.Date(fin_visita) == fecha_seleccionada) %>%
  arrange(fin_visita) %>%
  slice(1:n_entregas) %>%
  mutate(
    orden = row_number(),  # Agregar el orden de entrega
    tiempo_transcurrido = c(NA, diff(fin_visita) / 60)  # Calcular minutos entre entregas
  )

# Crear la paleta de colores basada en el valor del cliente
paleta_colores <- colorFactor(
  palette = c("red", "green"),  # Asignar colores específicos
  domain = entregas_fecha$cliente  # Basado en los valores de la columna cliente
)

# Crear etiquetas de tiempo entre entregas para colocarlas en las líneas
etiquetas_lineas <- entregas_fecha %>%
  filter(!is.na(tiempo_transcurrido)) %>%  # Excluir la primera entrega (sin tiempo anterior)
  mutate(
    lat_medio = (latitud + lag(latitud)) / 2,
    lng_medio = (longitud + lag(longitud)) / 2,
    etiqueta_tiempo = paste0(round(tiempo_transcurrido, 2), " min")
  ) %>%
  na.omit()  # Remover filas con NA (la primera fila)

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = entregas_fecha) %>%
  addTiles() %>%
  # Agregar puntos con colores basados en el cliente y etiquetas personalizadas
  addCircleMarkers(
    ~longitud, ~latitud,
    radius = 8,
    color = "black",
    fillColor = ~paleta_colores(cliente),
    fillOpacity = 0.8,
    label = ~as.character(orden),  # Mostrar el número de orden como etiqueta
    labelOptions = labelOptions(
      noHide = TRUE, 
      direction = "center", 
      textOnly = TRUE,
      style = list(
        "font-size" = "13px",
        "font-weight" = "bold",
        "color" = "white",
        "border-radius" = "100%",
        "padding" = "12px"
      )
    ),
    # Mostrar la hora exacta y tiempo transcurrido como popup
    popup = ~paste(
      "Hora de Entrega:", format(fin_visita, "%H:%M:%S"),
      "<br>Cliente:", cliente,
      "<br>Tiempo desde la última entrega:", 
      ifelse(is.na(tiempo_transcurrido), "N/A", 
             paste(round(tiempo_transcurrido, 2), "min"))
    )
  ) %>%
  # Agregar líneas que conecten las entregas en orden
  addPolylines(
    lng = ~longitud, lat = ~latitud,
    data = entregas_fecha,
    color = "blue", weight = 2
  ) %>%
  # Agregar etiquetas sobre las líneas con tiempo transcurrido
  addLabelOnlyMarkers(
    lng = ~lng_medio, lat = ~lat_medio,
    label = ~etiqueta_tiempo,
    data = etiquetas_lineas,
    labelOptions = labelOptions(
      noHide = TRUE, 
      direction = "top", 
      style = list(
        "font-size" = "10px",
        "font-weight" = "bold",
        "color" = "blue"
      )
    )
  ) %>%
  # Agregar una leyenda para los clientes
  addLegend(
    "bottomright", 
    pal = paleta_colores, 
    values = ~cliente, 
    title = "Cliente", 
    opacity = 1
  )

# Mostrar el mapa
mapa_leaflet
```

Como vemos largas distancias en poco tiempo sabemos que sucede gracias a camiones distintos. ¿Como podemos identificarlos?

### Identificar camiones.

Algunas observaciones:

-   Un mismo camion parece no entregar productos de distintos clientes.

A priori y para facilitar el análisis podríamos suponer que las entregas las realizan dos camiones. Uno para cada cliente. Podemos validar que esto es incorrecto al estudiar las entregas de un único cliente.

```{r echo=FALSE}
# Filtrar las entregas para la fecha seleccionada y ordenarlas por hora
entregas_fecha <- data %>%
  filter(as.Date(fin_visita) == fecha_seleccionada,
         cliente == 20) %>%
  arrange(fin_visita) %>%
  slice(1:n_entregas) %>%
  mutate(
    orden = row_number(),  # Agregar el orden de entrega
    tiempo_transcurrido = c(NA, diff(fin_visita) / 60)  # Calcular minutos entre entregas
  )

# Crear etiquetas de tiempo entre entregas para colocarlas en las líneas
etiquetas_lineas <- entregas_fecha %>%
  filter(!is.na(tiempo_transcurrido)) %>%  # Excluir la primera entrega (sin tiempo anterior)
  mutate(
    lat_medio = (latitud + lag(latitud)) / 2,
    lng_medio = (longitud + lag(longitud)) / 2,
    etiqueta_tiempo = paste0(round(tiempo_transcurrido, 2), " min")
  ) %>%
  na.omit()  # Remover filas con NA (la primera fila)

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = entregas_fecha) %>%
  addTiles() %>%
  # Agregar puntos con colores basados en el cliente y etiquetas personalizadas
  addCircleMarkers(
    ~longitud, ~latitud,
    radius = 8,
    color = "red",
    label = ~as.character(orden),  # Mostrar el número de orden como etiqueta
    labelOptions = labelOptions(
      noHide = TRUE, 
      direction = "center", 
      textOnly = TRUE,
      style = list(
        "font-size" = "13px",
        "font-weight" = "bold",
        "color" = "white",
        "border-radius" = "100%",
        "padding" = "12px"
      )
    ),
    # Mostrar la hora exacta y tiempo transcurrido como popup
    popup = ~paste(
      "Hora de Entrega:", format(fin_visita, "%H:%M:%S"),
      "<br>Cliente:", cliente,
      "<br>Tiempo desde la última entrega:", 
      ifelse(is.na(tiempo_transcurrido), "N/A", 
             paste(round(tiempo_transcurrido, 2), "min"))
    )
  ) %>%
  # Agregar líneas que conecten las entregas en orden
  addPolylines(
    lng = ~longitud, lat = ~latitud,
    data = entregas_fecha,
    color = "blue", weight = 2
  ) %>%
  # Agregar una leyenda para los clientes
  addLegend(
    "bottomright", 
    pal = paleta_colores, 
    values = ~cliente, 
    title = "Cliente", 
    opacity = 1
  )

# Mostrar el mapa
mapa_leaflet
```

Vemos que entre la entrega 18 y 19 pasaron menos de 3min

Hay algunos casos donde podemos identificar camiones distintos:

-   Grandes distancias en poco tiempo.

-   Cruces de rutas.

Los cruces de trayectorias podrían indicar rutas ineficientes de los repartidores o que se estan siguiendo varios repartidores en la misma ruta. Podemos verlo de forma clara en el siguiente gráfico:

```{r echo=FALSE}
# Filtrar las entregas para la fecha seleccionada y ordenarlas por hora
entregas_fecha <- data %>%
  filter(as.Date(fin_visita) == fecha_seleccionada,
         cliente == 70) %>%
  arrange(fin_visita) %>%
  slice(1:n_entregas) %>%
  mutate(
    orden = row_number(),  # Agregar el orden de entrega
    tiempo_transcurrido = c(NA, diff(fin_visita) / 60)  # Calcular minutos entre entregas
  )

# Crear etiquetas de tiempo entre entregas para colocarlas en las líneas
etiquetas_lineas <- entregas_fecha %>%
  filter(!is.na(tiempo_transcurrido)) %>%  # Excluir la primera entrega (sin tiempo anterior)
  mutate(
    lat_medio = (latitud + lag(latitud)) / 2,
    lng_medio = (longitud + lag(longitud)) / 2,
    etiqueta_tiempo = paste0(round(tiempo_transcurrido, 2), " min")
  ) %>%
  na.omit()  # Remover filas con NA (la primera fila)

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = entregas_fecha) %>%
  addTiles() %>%
  # Agregar puntos con colores basados en el cliente y etiquetas personalizadas
  addCircleMarkers(
    ~longitud, ~latitud,
    radius = 8,
    color = "blue",
    label = ~as.character(orden),  # Mostrar el número de orden como etiqueta
    labelOptions = labelOptions(
      noHide = TRUE, 
      direction = "center", 
      textOnly = TRUE,
      style = list(
        "font-size" = "13px",
        "font-weight" = "bold",
        "color" = "white",
        "border-radius" = "100%",
        "padding" = "12px"
      )
    ),
    # Mostrar la hora exacta y tiempo transcurrido como popup
    popup = ~paste(
      "Hora de Entrega:", format(fin_visita, "%H:%M:%S"),
      "<br>Cliente:", cliente,
      "<br>Tiempo desde la última entrega:", 
      ifelse(is.na(tiempo_transcurrido), "N/A", 
             paste(round(tiempo_transcurrido, 2), "min"))
    )
  ) %>%
  # Agregar líneas que conecten las entregas en orden
  addPolylines(
    lng = ~longitud, lat = ~latitud,
    data = entregas_fecha,
    color = "blue", weight = 2
  ) %>%
  # Agregar una leyenda para los clientes
  addLegend(
    "bottomright", 
    pal = paleta_colores, 
    values = ~cliente, 
    title = "Cliente", 
    opacity = 1
  )

# Mostrar el mapa
mapa_leaflet
```

Habiendo identificado estas caracteristicas podríamos utilizar un modelo de agrupamiento para estimar distintos repartidores y sus trayectorias.

Esto tiene un gran valor para:

1.  Identificar rutas ineficientes.
2.  Estimar un tiempo de duración de cada entrega (Y rellenar vacios)
3.  Identificar patrones en los errores de carga de datos (Duración de entregas)

Para la aplicación practica de estos analisis sería vital tener acceso real a los camiones o repartidores responsables de cada entrega pero para el bien de este analisis intentamos aproximar lo más posible a estos datos utilizando modelos estadisticos. Esperamos sirva como prueba de concepto para evaluar el potencial de recolectar estos datos.

Esto nos presenta un problema de coloración de grafos

![](images/clipboard-2486824433.png)

**Construir el grafo de conflictos:**

-   **Nodos:** Cada nodo representa una entrega individual con su respectiva latitud, longitud, fecha y hora.

-   **Aristas (conflictos):** Se dibuja una arista entre dos entregas si es imposible que hayan sido realizadas por el mismo repartidor debido a restricciones de tiempo y distancia.

    -   **Criterio de conflicto:** Para dos entregas AAA y BBB, se calcula el tiempo mínimo necesario para que un repartidor viaje desde la ubicación de AAA a BBB considerando una velocidad razonable (por ejemplo, la velocidad promedio de un vehículo en esa área).

    -   Si el tiempo transcurrido entre la hora de entrega de AAA y BBB es menor que el tiempo mínimo de viaje calculado, entonces se establece un conflicto entre AAA y BBB.

**Algoritmos sugeridos:**

-   **Algoritmo Greedy de coloreo:** Un enfoque sencillo que asigna colores a los nodos de forma secuencial, utilizando el menor número de colores posible en cada paso.

-   **Heurísticas avanzadas:** Si el grafo es grande y complejo, pueden emplearse algoritmos como DSATUR o técnicas metaheurísticas (algoritmos genéticos, recocido simulado) para aproximar una solución cercana al mínimo número de colores.

## Sugerencia:

Combinar productos de entrega.Hay una gran perdida al restringir los productos a camiones diferentes.
