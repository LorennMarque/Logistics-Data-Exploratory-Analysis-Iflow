---
title: "segmentacion"
output: html_document
date: "2024-10-17"
---

```{r}
# Cargar datos
data <- read.csv("data/clean_iflow_data.csv")
head(data)
```

```{r}
library(dplyr)
library(ggplot2)
library(tidyverse)
library(viridis)
```

# Patrones en las entregas.

> ## "El lunes es tan parecido con el jueves como el martes con el viernes y el miercoles con el sabado"

```{r}
# Barchart con la cantidad total de entregas por cliente
barchart_cliente <- buenos_aires_data %>%
  group_by(cliente) %>%
  summarise(cantidad = n()) %>%
  ggplot(aes(x = factor(cliente), y = cantidad, fill = factor(cliente))) +
  geom_bar(stat = "identity") +
  labs(title = "Cantidad de Entregas por Cliente",
       x = "Cliente", y = "Cantidad de Entregas") +
  theme_minimal() +
  theme(legend.position = "none")  # Ocultar leyenda si los colores coinciden con los clientes

# Mostrar el gráfico
print(barchart_cliente)
```

```{r}
# Agrupar y contar la cantidad de entregas por cliente y día de la semana
entregas_por_cliente_dia <- buenos_aires_data %>%
  filter(!is.na(dia_str) & dia_str != "domingo") %>%
  group_by(cliente, dia_str) %>%
  summarise(cantidad = n()) %>%
  ungroup() %>%
  mutate(dia_str = factor(dia_str, 
                          levels = c("lunes", "martes", "miércoles", 
                                     "jueves", "viernes", "sábado")))

# Line chart de cantidad de entregas por cliente y día de la semana
linechart_cliente_dia <- entregas_por_cliente_dia %>%
  ggplot(aes(x = dia_str, y = cantidad, color = factor(cliente), group = cliente)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  labs(title = "Cantidad de Entregas por Día de la Semana y Cliente",
       x = "Día de la Semana", y = "Cantidad de Entregas", color = "Cliente") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Mostrar el gráfico
print(linechart_cliente_dia)
```

```{r}
# Agrupar y contar las entregas por cliente, día y mes
entregas_por_cliente_tiempo <- buenos_aires_data %>%
  group_by(cliente, dia, mes) %>%
  summarise(cantidad = n()) %>%
  ungroup() %>%
  mutate(fecha = as.Date(paste(mes, dia, sep = "-"), format = "%m-%d"))

# Line chart con la evolución de las entregas a lo largo del tiempo
linechart_cliente_tiempo <- entregas_por_cliente_tiempo %>%
  ggplot(aes(x = fecha, y = cantidad, color = factor(cliente), group = cliente)) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  labs(title = "Evolución de Entregas por Cliente a lo Largo del Tiempo",
       x = "Fecha", y = "Cantidad de Entregas", color = "Cliente") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Mostrar el gráfico
print(linechart_cliente_tiempo)

```

```{r}
# Filtrar los datos para excluir domingos y NAs en los días de la semana
buenos_aires_data <- buenos_aires_data %>%
  filter(!is.na(dia_str) & dia_str != "domingo") %>%
  mutate(
    dia_str = factor(dia_str, 
                     levels = c("lunes", "martes", "miércoles", 
                                "jueves", "viernes", "sábado"))
  )

# Crear el scatterplot con facetado por día de la semana
scatter_grid <- buenos_aires_data %>%
  ggplot(aes(x = longitud, y = latitud, color = factor(cliente))) +
  geom_point(alpha = 0.1, size = 1) +  # Transparencia para evitar solapamiento
  labs(title = "Entregas por Cliente y Día de la Semana",
       x = "Longitud", y = "Latitud", color = "Cliente") +
  theme_minimal() +
  theme(legend.position = "bottom") +  # Leyenda en la parte inferior
  facet_wrap(~ dia_str)  # Crear un scatterplot para cada día de la semana

# Mostrar el gráfico
print(scatter_grid)
```

Vamos a calcular la **similitud espacial** de las entregas de cada cliente por **latitud y longitud** para los diferentes días de la semana.

Para esto:

1.  **Calcularemos la distancia entre los puntos (latitud y longitud)** para cada par de días.

2.  **Generamos una matriz de distancias** por cliente, mostrando qué días tienen entregas más similares.

3.  **Visualizamos la matriz de similitudes** usando un **heatmap**.

### **Resultado Esperado:**

Este **heatmap** permitirá ver:

-   **Qué días tienen entregas más similares** para cada cliente (por ejemplo, si lunes y viernes son parecidos).

-   Identificar patrones geográficos de las entregas a lo largo de los días.

```{r}
# Cargar librerías necesarias
library(dplyr)
library(tidyr)
library(ggplot2)
library(reshape2)

# Filtrar los datos para asegurar que no haya NA y excluir domingos
buenos_aires_data <- buenos_aires_data %>%
  filter(!is.na(dia_str) & dia_str != "domingo") %>%
  mutate(
    dia_str = factor(dia_str, 
                     levels = c("lunes", "martes", "miércoles", 
                                "jueves", "viernes", "sábado"))
  )

# Función para calcular la distancia euclidiana promedio entre dos días
calcular_distancia <- function(data, dia1, dia2) {
  subset1 <- data %>% filter(dia_str == dia1) %>% select(latitud, longitud)
  subset2 <- data %>% filter(dia_str == dia2) %>% select(latitud, longitud)
  
  # Si alguno de los días no tiene datos, devolvemos NA
  if (nrow(subset1) == 0 | nrow(subset2) == 0) return(NA)
  
  distancias <- dist(rbind(subset1, subset2))
  mean(as.numeric(distancias))  # Promedio de las distancias
}

# Crear una matriz de distancias para cada cliente
clientes <- unique(buenos_aires_data$cliente)
dias <- levels(buenos_aires_data$dia_str)

resultados <- lapply(clientes, function(cliente) {
  # Filtrar los datos del cliente
  data_cliente <- buenos_aires_data %>% filter(cliente == cliente)
  
  # Inicializar la matriz de distancias
  matriz <- matrix(NA, nrow = length(dias), ncol = length(dias), 
                   dimnames = list(dias, dias))
  
  # Rellenar la matriz con distancias promedio entre pares de días
  for (i in dias) {
    for (j in dias) {
      matriz[i, j] <- calcular_distancia(data_cliente, i, j)
    }
  }
  list(cliente = cliente, matriz = matriz)
})

# Transformar las matrices de distancia a formato largo para ggplot2
resultados_largos <- do.call(rbind, lapply(resultados, function(res) {
  melt(res$matriz) %>% 
    mutate(cliente = res$cliente)
}))

# Crear el heatmap de similitudes espaciales
heatmap_similitud <- resultados_largos %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  facet_wrap(~ cliente) +
  scale_fill_gradient(low = "white", high = "red", na.value = "gray50") +
  labs(title = "Similitud Espacial de Entregas por Día de la Semana",
       x = "Día 1", y = "Día 2", fill = "Distancia Media") +
  theme_minimal()

# Mostrar el gráfico
print(heatmap_similitud)


```

# Identificar entregas recurrentes

# Segmentación en zonas de entregas

```{r}
# Cargar librerías necesarias
library(dplyr)
library(ggplot2)
library(factoextra)

# Filtrar los datos de Buenos Aires
buenos_aires_data <- data %>%
  filter(latitud >= -35.2, latitud <= -34.3,
         longitud >= -58.8, longitud <= -57.9)

# Extraer las coordenadas
coords <- buenos_aires_data %>%
  select(latitud, longitud)

# Método del codo para determinar el número óptimo de clusters
set.seed(123)
wss_values <- sapply(1:10, function(k) {
  kmeans(coords, centers = k, nstart = 10)$tot.withinss
})

# Graficar el método del codo con ggplot2
elbow_plot <- data.frame(K = 1:10, WSS = wss_values) %>%
  ggplot(aes(x = K, y = WSS)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 4, linetype = "dashed", color = "red") +
  annotate("text", x = 4.2, y = wss_values[4] + 10, 
           label = "Elección óptima de K", color = "red", hjust = 0) +
  labs(title = "Método del codo para determinar K óptimo",
       x = "Número de Clusters K",
       y = "Suma de cuadrados dentro del cluster (WSS)") +
  theme_minimal()

print(elbow_plot)
```

```{r}
# Aplicar K-means con K = 4
set.seed(123)
kmeans_result <- kmeans(coords, centers = 4, nstart = 10)

# Agregar los clusters al DataFrame original
buenos_aires_data <- buenos_aires_data %>%
  mutate(cluster = as.factor(kmeans_result$cluster))

# Visualizar los clusters con ggplot2
cluster_plot <- buenos_aires_data %>%
  ggplot(aes(x = longitud, y = latitud, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  labs(title = "Clusters de Buenos Aires", 
       x = "Longitud", y = "Latitud") +
  theme_minimal() +
  theme(legend.position = "bottom")

print(cluster_plot)

```

```{r}
library(leaflet)
# Visualizar los clusters en un mapa interactivo con leaflet
palette <- colorFactor(palette = "Set1", domain = buenos_aires_data$cluster)

leaflet(data = buenos_aires_data) %>%
  addTiles() %>%
  addCircleMarkers(~longitud, ~latitud, 
                   color = ~palette(cluster), 
                   radius = 2, fillOpacity = 0.8, 
                   popup = ~paste("Cluster:", cluster)) %>%
  addLegend("bottomright", pal = palette, values = ~cluster,
            title = "Clusters", opacity = 0.2)
```

```{r}
# Calcular la cantidad de entregas por cluster
entregas_por_cluster <- buenos_aires_data %>%
  group_by(cluster) %>%
  summarise(cantidad = n()) %>%
  ungroup()

# Crear el barchart con ajustes adicionales
barchart_cluster <- entregas_por_cluster %>%
  ggplot(aes(x = cluster, y = cantidad, fill = cluster)) +
  geom_bar(stat = "identity") +  # 'identity' para usar valores calculados
  geom_text(aes(label = cantidad), 
            vjust = -0.3, size = 5) +  # Ajustar la posición del texto
  labs(title = "Cantidad de Entregas por Cluster",
       x = "Cluster", y = "Cantidad de Entregas") +
  theme_minimal(base_size = 14) +  # Aumentar tamaño general del gráfico
  theme(
    legend.position = "none",  # Ocultar leyenda
    plot.margin = margin(t = 30, r = 10, b = 10, l = 10)  # Aumentar margen superior
  ) +
  ylim(0, max(entregas_por_cluster$cantidad) * 1.1)  # Expandir límite del eje Y

# Mostrar el gráfico
print(barchart_cluster)
```

```{r}
# Asegurar que 'dia_str' esté ordenado correctamente (de lunes a domingo)
buenos_aires_data <- buenos_aires_data %>%
  mutate(dia_str = factor(dia_str, 
                          levels = c("lunes", "martes", "miércoles", 
                                     "jueves", "viernes", "sábado", "domingo")))

# Crear el barchart usando ggplot2
barchart <- buenos_aires_data %>%
  filter(!is.na(dia_str) & dia_str != "domingo") %>%
  ggplot(aes(x = dia_str , fill = cluster)) +
  geom_bar(position = "dodge") +  # 'dodge' para barras agrupadas
  labs(title = "Cantidad de entregas por día y cluster",
       x = "Día de la semana", y = "Cantidad de entregas") +
  theme_minimal() +
  theme(legend.position = "bottom")  # Leyenda en la parte inferior

print(barchart)
```

```{r}
# Asegurar que 'dia_str' esté ordenado correctamente (de lunes a sábado)
buenos_aires_data <- buenos_aires_data %>%
  mutate(dia_str = factor(dia_str, 
                          levels = c("lunes", "martes", "miércoles", 
                                     "jueves", "viernes", "sábado", "domingo")))

# Agrupar y contar la cantidad de entregas por día y cluster
entregas_por_dia_cluster <- buenos_aires_data %>%
  filter(!is.na(dia_str) & dia_str != "domingo") %>%
  group_by(dia_str, cluster) %>%
  summarise(cantidad = n()) %>%
  ungroup()

# Crear el line chart usando ggplot2
linechart <- entregas_por_dia_cluster %>%
  ggplot(aes(x = dia_str, y = cantidad, color = cluster, group = cluster)) +
  geom_line(size = 1) +  # Dibujar líneas
  geom_point(size = 3) +  # Agregar puntos en los días
  labs(title = "Cantidad de Entregas por Día y Cluster",
       x = "Día de la semana", y = "Cantidad de Entregas") +
  theme_minimal() +
  theme(legend.position = "bottom")  # Leyenda en la parte inferior

# Mostrar el gráfico
print(linechart)
```

```{r}
# Asegurar que 'dia_str' esté ordenado correctamente (de lunes a domingo)

# Crear un dataframe con la cantidad de entregas por hora y cluster
entregas_por_hora_cluster <- buenos_aires_data %>%
  filter(hora > 10 & hora < 20) %>%
  group_by(hora, cluster) %>%
  summarise(cantidad = n()) %>%
  ungroup()

# Crear el line chart con ggplot2
linechart <- entregas_por_hora_cluster %>%
  ggplot(aes(x = hora, y = cantidad, color = cluster, group = cluster)) +
  geom_line(size = 1) +  # Líneas más gruesas
  geom_point(size = 3) +  # Puntos en cada hora
  labs(title = "Cantidad de Entregas por Hora y Cluster",
       x = "Hora del día", y = "Cantidad de Entregas") +
  theme_minimal() +
  theme(legend.position = "bottom")  # Leyenda en la parte inferior

# Mostrar el gráfico
print(linechart)

```

Estandarizamos la cantidad de entregas para estudiar si hay algun efecto de la hora de entrega segun la zona.

```{r}
# Calcular las proporciones por hora y cluster
entregas_normalizadas <- buenos_aires_data %>%
  filter(hora > 10 & hora < 20) %>%
  group_by(hora, cluster) %>%
  summarise(cantidad = n()) %>%
  ungroup() %>%
  group_by(hora) %>%
  mutate(proporcion = cantidad / sum(cantidad))  # Normalización por grupo de hora

# Crear el line chart normalizado
linechart_normalizado <- entregas_normalizadas %>%
  ggplot(aes(x = hora, y = proporcion, color = cluster, group = cluster)) +
  geom_line(size = 1) +  # Líneas más gruesas
  geom_point(size = 3) +  # Puntos en cada hora
  scale_y_continuous(labels = scales::percent) +  # Mostrar proporciones como porcentaje
  labs(title = "Proporción de Entregas por Hora y Cluster Normalizado",
       x = "Hora del día", y = "Proporción de Entregas") +
  theme_minimal() +
  theme(legend.position = "bottom")  # Leyenda en la parte inferior

# Mostrar el gráfico
print(linechart_normalizado)
```

# Entregas unicas por cliente?

```{r}
# 1. Contar la cantidad de entregas por id_orden y cliente
entregas_por_orden <- data %>%
  group_by(id_orden) %>%
  summarise(
    cantidad_entregas = n(),                     # Número total de entregas por orden
    clientes_unicos = n_distinct(cliente),        # Número de clientes diferentes por orden
    lista_clientes = paste(unique(cliente), collapse = ", ")  # Lista de clientes por orden
  ) %>%
  ungroup() %>% 
  arrange(desc(cantidad_entregas))

# Mostrar las primeras filas del resumen
print(head(entregas_por_orden))
```

```{r}
# Histograma para ver la distribución del número de entregas por orden
ggplot(entregas_por_orden, aes(x = cantidad_entregas)) +
  geom_histogram(binwidth = 1, fill = "skyblue", color = "black") +
  labs(title = "Distribución del Número de Entregas por Orden",
       x = "Cantidad de Entregas por Orden", y = "Frecuencia") +
  theme_minimal()
```

```{r}
# 2. Filtrar las órdenes con más de una entrega
ordenes_multiples <- entregas_por_orden %>%
  filter(cantidad_entregas > 1)

# Mostrar cuántas órdenes tienen más de una entrega
cat("Total de órdenes con más de una entrega:", nrow(ordenes_multiples), "\n")

```

```{r}
# 3. Analizar si las órdenes con múltiples entregas son de un solo cliente o más
resumen_clientes <- ordenes_multiples %>%
  count(clientes_unicos)  # Contar cuántas órdenes tienen 1 o más clientes únicos

# Mostrar el resumen de clientes por orden
print(resumen_clientes)

# 4. Visualización con un gráfico de barras
library(ggplot2)

ggplot(resumen_clientes, aes(x = factor(clientes_unicos), y = n, fill = factor(clientes_unicos))) +
  geom_bar(stat = "identity") +
  labs(title = "Distribución de Órdenes por Número de Clientes Únicos",
       x = "Número de Clientes Únicos en la Orden",
       y = "Cantidad de Órdenes") +
  theme_minimal() +
  theme(legend.position = "none")
```

El grafico anterior demuestra que no existe algun caso donde un domicilio haya recibido una entrega de tanto el cliente 70 como el 20 sino que son mutuamente excluyentes.

# Porcentaje de visitas dentro de rango horario planificado?

# Diferencias significativas entre el horario planificado y real de visitas?

Que tan dentro del margen de entrega estamos. Estamos entregando acorde a nuestra estimacion?

# Estudiamos la primera entrega de cada dia para identificar un punto de partida.

```{r}
# Asegurar que las columnas de fecha y hora estén en formato POSIXct
data <- data %>%
  mutate(
    fin_visita = as.POSIXct(fin_visita, format = "%Y-%m-%d %H:%M:%S")
  )

# Encontrar la primera entrega de cada día
primeras_entregas <- data %>%
  mutate(fecha = as.Date(fin_visita)) %>%
  group_by(fecha) %>%
  filter(fin_visita == min(fin_visita)) %>%
  ungroup()

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = primeras_entregas) %>%
  addTiles() %>%
  addCircleMarkers(
    ~longitud, ~latitud,
    radius = 3,
    color = "blue",
    fillOpacity = 0.8,
    popup = ~paste("Fecha:", fecha, "<br>Cliente:", cliente, "<br>Hora:", fin_visita)
  ) %>%
  addLegend(
    "bottomright", 
    colors = "blue", 
    labels = "Primera Entrega", 
    title = "Leyenda"
  )

# Mostrar el mapa
mapa_leaflet
```

Cada punto azul es la primera entrega de un día. Si hacemos un cluster podemos estimar ubicaciones de partida o intentar averiguar porque están tan dispersas

```{r}
# Cargar librerías necesarias
library(dplyr)
library(leaflet)

# Asegurar que la columna fin_visita esté en formato POSIXct
data <- data %>%
  mutate(
    fin_visita = as.POSIXct(fin_visita, format = "%Y-%m-%d %H:%M:%S")
  )

# Encontrar la primera y la segunda entrega de cada día
entregas_dia <- data %>%
  mutate(fecha = as.Date(fin_visita)) %>%
  group_by(fecha) %>%
  arrange(fin_visita) %>%  # Ordenar por hora de finalización
  slice(1:2) %>%  # Seleccionar las dos primeras entregas
  mutate(tipo = ifelse(row_number() == 1, "Primera Entrega", "Segunda Entrega")) %>%
  ungroup()

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = entregas_dia) %>%
  addTiles() %>%
  addCircleMarkers(
    data = entregas_dia %>% filter(tipo == "Primera Entrega"),
    ~longitud, ~latitud,
    radius = 5,
    color = "blue",
    fillOpacity = 0.8,
    popup = ~paste("Fecha:", fecha, "<br>Cliente:", cliente, "<br>Hora:", fin_visita)
  ) %>%
  addCircleMarkers(
    data = entregas_dia %>% filter(tipo == "Segunda Entrega"),
    ~longitud, ~latitud,
    radius = 5,
    color = "red",
    fillOpacity = 0.8,
    popup = ~paste("Fecha:", fecha, "<br>Cliente:", cliente, "<br>Hora:", fin_visita)
  ) %>%
  addLegend(
    "bottomright", 
    colors = c("blue", "red"), 
    labels = c("Primera Entrega", "Segunda Entrega"), 
    title = "Leyenda"
  )

# Mostrar el mapa
mapa_leaflet

```

Los puntos rojos son la segunda entrega del día.

Cada punto azul debería estar muy cerca de un punto rojo y no debería existir ningún otra entrega entre esos dos puntos.

Si demostramos que en algún dia existen entrega entre los primeros k puntos del dia podríamos decir que las entregas no son eficientes

```{r}
# Cargar librerías necesarias
library(dplyr)
library(leaflet)

# Parámetros: Selección de fecha específica y cantidad de entregas a mostrar
fecha_seleccionada <- as.Date("2024-05-23")  # Cambia la fecha según lo que desees
n_entregas <- 40  # Cambia este valor para limitar el número de entregas mostradas

# Asegurar que la columna fin_visita esté en formato POSIXct
data <- data %>%
  mutate(
    fin_visita = as.POSIXct(fin_visita, format = "%Y-%m-%d %H:%M:%S")
  )

# Filtrar las entregas para la fecha seleccionada y ordenarlas por hora
entregas_fecha <- data %>%
  filter(as.Date(fin_visita) == fecha_seleccionada) %>%
  arrange(fin_visita) %>%
  slice(1:n_entregas) %>%
  mutate(
    orden = row_number(),  # Agregar el orden de entrega
    tiempo_transcurrido = c(NA, diff(fin_visita) / 60)  # Calcular minutos entre entregas
  )

# Crear la paleta de colores basada en el valor del cliente
paleta_colores <- colorFactor(
  palette = c("red", "green"),  # Asignar colores específicos
  domain = entregas_fecha$cliente  # Basado en los valores de la columna cliente
)

# Crear etiquetas de tiempo entre entregas para colocarlas en las líneas
etiquetas_lineas <- entregas_fecha %>%
  filter(!is.na(tiempo_transcurrido)) %>%  # Excluir la primera entrega (sin tiempo anterior)
  mutate(
    lat_medio = (latitud + lag(latitud)) / 2,
    lng_medio = (longitud + lag(longitud)) / 2,
    etiqueta_tiempo = paste0(round(tiempo_transcurrido, 2), " min")
  ) %>%
  na.omit()  # Remover filas con NA (la primera fila)

# Crear el mapa interactivo con Leaflet
mapa_leaflet <- leaflet(data = entregas_fecha) %>%
  addTiles() %>%
  # Agregar puntos con colores basados en el cliente y etiquetas personalizadas
  addCircleMarkers(
    ~longitud, ~latitud,
    radius = 8,
    color = "black",
    fillColor = ~paleta_colores(cliente),
    fillOpacity = 0.8,
    label = ~as.character(orden),  # Mostrar el número de orden como etiqueta
    labelOptions = labelOptions(
      noHide = TRUE, 
      direction = "center", 
      textOnly = TRUE,
      style = list(
        "font-size" = "13px",
        "font-weight" = "bold",
        "color" = "white",
        "border-radius" = "100%",
        "padding" = "12px"
      )
    ),
    # Mostrar la hora exacta y tiempo transcurrido como popup
    popup = ~paste(
      "Hora de Entrega:", format(fin_visita, "%H:%M:%S"),
      "<br>Cliente:", cliente,
      "<br>Tiempo desde la última entrega:", 
      ifelse(is.na(tiempo_transcurrido), "N/A", 
             paste(round(tiempo_transcurrido, 2), "min"))
    )
  ) %>%
  # Agregar líneas que conecten las entregas en orden
  addPolylines(
    lng = ~longitud, lat = ~latitud,
    data = entregas_fecha,
    color = "blue", weight = 2
  ) %>%
  # Agregar etiquetas sobre las líneas con tiempo transcurrido
  addLabelOnlyMarkers(
    lng = ~lng_medio, lat = ~lat_medio,
    label = ~etiqueta_tiempo,
    data = etiquetas_lineas,
    labelOptions = labelOptions(
      noHide = TRUE, 
      direction = "top", 
      style = list(
        "font-size" = "10px",
        "font-weight" = "bold",
        "color" = "blue"
      )
    )
  ) %>%
  # Agregar una leyenda para los clientes
  addLegend(
    "bottomright", 
    pal = paleta_colores, 
    values = ~cliente, 
    title = "Cliente", 
    opacity = 1
  )

# Mostrar el mapa
mapa_leaflet

```

## DBSCAN clustering

```{r}
# Instalar paquetes necesarios (si no están instalados)
if (!requireNamespace("dbscan", quietly = TRUE)) install.packages("dbscan")
if (!requireNamespace("lubridate", quietly = TRUE)) install.packages("lubridate")
if (!requireNamespace("leaflet", quietly = TRUE)) install.packages("leaflet")

# Cargar los paquetes
library(dbscan)
library(lubridate)
library(leaflet)

# Parámetro: Número de entregas que queremos tomar
N_entregas <- 20  # Cambia este valor según tus necesidades

# Ver las primeras filas para revisar la estructura de los datos
head(data)

# Convertir 'fin_visita' a formato datetime
data$fin_visita <- ymd_hms(data$fin_visita)

# Filtrar los datos para el día 2024-05-23
data_filtrado <- data[as.Date(data$fin_visita) == as.Date("2024-05-23"), ]

# Ordenar las entregas por el tiempo de 'fin_visita'
data_filtrado <- data_filtrado[order(data_filtrado$fin_visita), ]

# Tomar solo las primeras N entregas
data_filtrado <- head(data_filtrado, N_entregas)

# Crear una columna de tiempo en segundos desde la medianoche
data_filtrado$hora_segundos <- as.numeric(difftime(data_filtrado$fin_visita, 
                                                   floor_date(data_filtrado$fin_visita, "day"), 
                                                   units = "secs"))

# Verificar si hay valores NA en las columnas clave
print(colSums(is.na(data_filtrado[, c("latitud", "longitud", "hora_segundos")])))

# Eliminar filas con valores NA
data_clean <- na.omit(data_filtrado)

# Seleccionar las columnas necesarias para el clustering
X <- data_clean[, c("latitud", "longitud", "hora_segundos","cliente")]

# Escalar las variables
X_scaled <- scale(X)

# Ajustar los parámetros de DBSCAN
eps_value <- 1.6  # Ajustar según la dispersión de tus datos
minPts_value <- 10  # Mínimo de puntos para formar un cluster

# Aplicar DBSCAN
clustering <- dbscan(X_scaled, eps = eps_value, minPts = minPts_value)

# Añadir los resultados del cluster a los datos originales
data_clean$cluster <- as.factor(clustering$cluster)

# Crear una paleta de colores para los clusters
paleta_colores <- colorFactor(
  palette = rainbow(length(unique(data_clean$cluster))),
  domain = data_clean$cluster
)

# Ver los resultados del clustering
print(table(data_clean$cluster))

# Crear un mapa interactivo usando leaflet
leaflet(data_clean) %>%
  addTiles() %>%  # Añade el mapa base
  addCircleMarkers(
    ~longitud, ~latitud,  # Coordenadas
    color = ~paleta_colores(cluster),  # Aplicar la paleta de colores según el cluster
    radius = 5,  # Tamaño del marcador
    stroke = FALSE, fillOpacity = 0.7,  # Opciones estéticas
    popup = ~paste("Cliente:", cliente, "<br>",
                   "Cluster:", cluster, "<br>",
                   "Hora de entrega:", fin_visita)  # Información en popup
  ) %>%
  addLegend(
    "bottomright", 
    pal = paleta_colores,
    values = ~cluster,
    title = "Cluster",
    opacity = 1
  )

```

### Para identificar un EPS ideal para nuestro clustering.

```{r}
# Calcular las distancias al vecino más cercano para determinar el eps adecuado
library(ggplot2)

# Calcular la matriz de distancias con kNN (k=2 para el vecino más cercano)
kNNdist <- kNNdist(X_scaled, k = 2)

# Graficar las distancias al vecino más cercano para encontrar el codo
kNNdistplot(X_scaled, k = 2)
abline(h = 0.2, col = "red", lty = 2)  # Ajustar este valor según el gráfico
```

```{r}
# Cargar los paquetes
library(dbscan)
library(geosphere)
library(dplyr)
library(leaflet)

# Tus datos originales en 'buenos_aires_data'
entregas <- data_filtrado

# 1. Limitar a N entregas (por ejemplo, N = 100)
N <- 20  # Cambia este valor si es necesario
entregas <- entregas %>% slice(1:N)

```

```{r}
clasificar_entregas <- function(datos, max_dist_km, min_tiempo_por_km) {
  resultados <- datos %>%
    group_by(cliente) %>%
    arrange(fin_visita) %>%
    mutate(
      dist_km = c(0, distHaversine(cbind(longitud[-n()], latitud[-n()]),
                                   cbind(longitud[-1], latitud[-1])) / 1000),
      tiempo_min = c(0, difftime(fin_visita[-1], fin_visita[-n()], units = "mins")),
      nuevo_repartidor = (dist_km > max_dist_km) | (tiempo_min < dist_km * min_tiempo_por_km),
      grupo = cumsum(nuevo_repartidor)
    ) %>%
    ungroup()
  return(resultados)
}

```

```{r}
# Instalar el paquete 'progress' si no lo tienes
if (!requireNamespace("progress", quietly = TRUE)) install.packages("progress")

# Cargar los paquetes necesarios
library(progress)
library(dplyr)

# Rango ampliado de parámetros
max_distancias <- seq(1, 160, by = 2)     # Ej: 1, 3, 5, ..., 159 km
min_tiempos <- seq(1, 120, by = 1)        # Ej: 1, 2, ..., 120 min/km

# Generar todas las combinaciones posibles
resultados_grid <- expand.grid(max_dist_km = max_distancias, min_tiempo_por_km = min_tiempos)

# Inicializar la barra de progreso
total_combinaciones <- nrow(resultados_grid)
pb <- progress_bar$new(
  format = "Evaluando [:bar] :percent en :elapsed, quedan :eta",
  total = total_combinaciones, clear = FALSE, width = 60
)

# Inicializamos una variable para almacenar la mejor combinación
mejor_resultado <- NULL

# Bucle para evaluar cada combinación hasta encontrar 2 grupos
for (i in seq_len(total_combinaciones)) {
  # Obtener los parámetros actuales
  dist <- resultados_grid$max_dist_km[i]
  tiempo <- resultados_grid$min_tiempo_por_km[i]
  
  # Actualizar la barra de progreso
  pb$tick()
  
  # Ejecutar la clasificación con los parámetros actuales
  resultados <- clasificar_entregas(entregas, dist, tiempo)
  num_grupos <- evaluar_modelo(resultados)  # Número de grupos generados
  
  # Verificar si encontramos exactamente 2 grupos
  if (num_grupos == 2) {
    mejor_resultado <- data.frame(max_dist_km = dist, min_tiempo_por_km = tiempo, evaluacion = num_grupos)
    break  # Detener la búsqueda
  }
}

# Mostrar la mejor combinación encontrada
if (!is.null(mejor_resultado)) {
  print("¡Combinación encontrada que genera 2 grupos!")
  print(mejor_resultado)
} else {
  print("No se encontró ninguna combinación que genere exactamente 2 grupos.")
}

```

```{r}
 leaflet(entregas) %>%
    addTiles() %>%  # Añadir mapa base
    addCircleMarkers(
      ~longitud, ~latitud,
      radius = 5, color = "blue", stroke = FALSE, fillOpacity = 0.7,
      label = ~paste("Cliente:", cliente, "<br>Hora:", fin_visita)
    ) %>%
    addLegend("topright", colors = "blue", labels = "Entregas", opacity = 1)
```

```{r}

resultados <- clasificar_entregas(entregas,max_dist_km = 3, min_tiempo_por_km = 1)

# Crear una paleta de colores para los grupos
num_grupos <- length(unique(resultados$grupo))
palette <- colorFactor(topo.colors(num_grupos), resultados$grupo)

# Visualización en un mapa interactivo con leaflet
leaflet(resultados) %>%
  addTiles() %>%
  addCircleMarkers(
    ~longitud, ~latitud,
    color = ~palette(grupo),
    radius = 5,
    stroke = FALSE, fillOpacity = 1,
    label = ~paste("Cliente:", cliente, "<br>Grupo:", grupo, "<br>Hora:", fin_visita)
  )
```

------------------------------------------------------------------------

```{r}
library(h3)
```
